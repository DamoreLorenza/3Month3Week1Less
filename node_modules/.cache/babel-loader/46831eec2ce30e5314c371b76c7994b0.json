{"ast":null,"code":"// qui vado a dichiarare il reducer del mio store, ovvero quella funzione PURA (da tot input ottengo sempre tot output)\n// il cui compito è generare un nuovo stato ogni volta che viene \"dispatchata\" un'azione\nconst initialState = {\n  // divido il Redux Store in compartimenti, in modo da tenerlo ordinato e potenzialmente avere una struttura\n  // capace di crescere in futuro, se deciderò di ampliare le funzionalità dall'app\n  pref: {\n    content: [] // l'effettivo array contenente i libri aggiunti al carrello\n\n  }\n};\n\nconst mainReducer = function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let // lo stato attuale, con un valore di default per inizializzarlo con dei valori prefissati\n  action // l'ultima azione \"dispatchata\"\n  = arguments.length > 1 ? arguments[1] : undefined;\n\n  // ora descriviamo la logica di funzionamento del reducer\n  // dobbiamo dichiarare COME il reducer calcolerà il nuovo stato dell'app!\n  switch (action.type) {\n    case 'ADD_TO_FAVORITET':\n      // in OGNI case dobbiamo tornare il NUOVO stato dell'applicativo! dobbiamo tornare un oggetto!\n      // state.cart.content.push // ESPLOSIONI! perchè? perchè abbiamo modificato state...\n      return { ...state,\n        // mi porto dentro il NUOVO stato tutto il contenuto del vecchio\n        pref: { ...state.cart,\n          // non voglio perdere niente per strada, neanche eventuali altre proprietà di cart\n          content: [...state.pref.content, action.payload] //   content: state.cart.content.concat(action.payload),\n\n        }\n      };\n\n    case 'REMOVE_FROM_FAVORITE':\n      // in OGNI case dobbiamo tornare il NUOVO stato dell'applicativo! dobbiamo tornare un oggetto!\n      return { ...state,\n        pref: { ...state.pref,\n          content: state.pref.content.filter((data, i) => i !== action.payload)\n        }\n      };\n\n    default:\n      return state;\n  }\n};\n\nexport default mainReducer;","map":{"version":3,"names":["initialState","pref","content","mainReducer","state","action","type","cart","payload","filter","data","i"],"sources":["C:/Users/HP/Desktop/3week1less/d9-hw-start/src/redux/reducers/indexx.js"],"sourcesContent":["// qui vado a dichiarare il reducer del mio store, ovvero quella funzione PURA (da tot input ottengo sempre tot output)\r\n// il cui compito è generare un nuovo stato ogni volta che viene \"dispatchata\" un'azione\r\n\r\nconst initialState = {\r\n    // divido il Redux Store in compartimenti, in modo da tenerlo ordinato e potenzialmente avere una struttura\r\n    // capace di crescere in futuro, se deciderò di ampliare le funzionalità dall'app\r\n    pref: {\r\n      content: [], // l'effettivo array contenente i libri aggiunti al carrello\r\n    },\r\n  }\r\n  \r\n  const mainReducer = (\r\n    state = initialState, // lo stato attuale, con un valore di default per inizializzarlo con dei valori prefissati\r\n    action // l'ultima azione \"dispatchata\"\r\n  ) => {\r\n    // ora descriviamo la logica di funzionamento del reducer\r\n    // dobbiamo dichiarare COME il reducer calcolerà il nuovo stato dell'app!\r\n    switch (action.type) {\r\n      case 'ADD_TO_FAVORITET':\r\n        // in OGNI case dobbiamo tornare il NUOVO stato dell'applicativo! dobbiamo tornare un oggetto!\r\n        // state.cart.content.push // ESPLOSIONI! perchè? perchè abbiamo modificato state...\r\n        return {\r\n          ...state, // mi porto dentro il NUOVO stato tutto il contenuto del vecchio\r\n          pref: {\r\n            ...state.cart, // non voglio perdere niente per strada, neanche eventuali altre proprietà di cart\r\n            content: [...state.pref.content, action.payload],\r\n            //   content: state.cart.content.concat(action.payload),\r\n          },\r\n        }\r\n  \r\n      case 'REMOVE_FROM_FAVORITE':\r\n        // in OGNI case dobbiamo tornare il NUOVO stato dell'applicativo! dobbiamo tornare un oggetto!\r\n        return {\r\n          ...state,\r\n          pref: {\r\n            ...state.pref,\r\n            content: state.pref.content.filter(\r\n              (data, i) => i !== action.payload\r\n            \r\n            ),\r\n  \r\n            }\r\n        }\r\n  \r\n      default:\r\n        return state\r\n    }\r\n  }\r\n  \r\n  export default mainReducer"],"mappings":"AAAA;AACA;AAEA,MAAMA,YAAY,GAAG;EACjB;EACA;EACAC,IAAI,EAAE;IACJC,OAAO,EAAE,EADL,CACS;;EADT;AAHW,CAArB;;AAQE,MAAMC,WAAW,GAAG,YAGf;EAAA,IAFHC,KAEG,uEAFKJ,YAEL;EAAA,IAFmB;EACtBK,MACG,CADI;EACJ;;EACH;EACA;EACA,QAAQA,MAAM,CAACC,IAAf;IACE,KAAK,kBAAL;MACE;MACA;MACA,OAAO,EACL,GAAGF,KADE;QACK;QACVH,IAAI,EAAE,EACJ,GAAGG,KAAK,CAACG,IADL;UACW;UACfL,OAAO,EAAE,CAAC,GAAGE,KAAK,CAACH,IAAN,CAAWC,OAAf,EAAwBG,MAAM,CAACG,OAA/B,CAFL,CAGJ;;QAHI;MAFD,CAAP;;IASF,KAAK,sBAAL;MACE;MACA,OAAO,EACL,GAAGJ,KADE;QAELH,IAAI,EAAE,EACJ,GAAGG,KAAK,CAACH,IADL;UAEJC,OAAO,EAAEE,KAAK,CAACH,IAAN,CAAWC,OAAX,CAAmBO,MAAnB,CACP,CAACC,IAAD,EAAOC,CAAP,KAAaA,CAAC,KAAKN,MAAM,CAACG,OADnB;QAFL;MAFD,CAAP;;IAYF;MACE,OAAOJ,KAAP;EA5BJ;AA8BD,CApCD;;AAsCA,eAAeD,WAAf"},"metadata":{},"sourceType":"module"}